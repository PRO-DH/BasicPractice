#------------------- Day 10----------------------

print("\n\n\n\n\n\n 06.21. \n\n\n\n\n\n")       # 다양한 함수 및 import / 게임만들기


#### 자판기 리스트로 조금더 깔끔하게 처리하는 법 + import os와 time 으로 강화
import time
import os
n = 0
price = [300,300,200]
m = ["콜라",'사이다','커피']
while True:
    print("----Menu----\n1. 콜라 / 300\n2. 사이다 / 300\n3. 커피 / 200\n4. 돈넣기\n5. 잔돈 반환\n6. 종료\n--------------")
    print(f"현재 금액 : {n}")
    menu = int(input("메뉴 선택 : "))
    print()
    if menu == 4 :                  # 처음 돈 넣기
        n += int(input("돈을 넣어주세요 : "))
        print()
    elif 0 < menu < 4 :               # 골랐을때
        if n - price[menu-1] >= 0 :        # 돈이 많은 경우
            n -= price[menu-1]
            print(f"{m[menu-1]} 맛있게 드세요!")            
        else :                   # 돈이 부족한 경우
            print("금액이 부족합니다.")

    elif menu == 5 :            # 잔돈 반환
        print("잔돈이 반환됩니다.")
    elif menu == 6:
        print("이용해주셔서 감사합니다.")
        break
    time.sleep(0.5)         # 사용자가 직접 넘기게 하려면input()을 넣으면 된다.
    os.system("cls")
import random       #random.py 라는 파일 만들지 않기
import time
import os
# random.randit(a,b) a에서 b 까지 수 중 랜덤으로 하나를 반환
# time.sleep(a) a초 만큼 딜레이 후 실행 
# os.system("cls") 화면 지움



#### 홀짝 게임 ( 강화버전 )
life = 5
score = 0
while True : 
    print(f"점수 : {score}\n목숨 :"+"♥"*life+"♡"*(5-life))
    com = random.randint(10,99)
    print("="*30)
    print()
    user = (input("홀(1), 짝(0) : "))
    print()
    if user.isnumeric() :
        if com % 2 == int(user) :
            print("맞았습니다.")
            score += 100
        else:
            print("틀렸습니다.")
            life -= 1
            if life == 0 :
                time.sleep(1)
                print()
                print()
                print(f"Game Over. 점수는{score}")
                print()
                print()
                break
    else : 
        print("입력오류")
    print()
    time.sleep(0.7)
    os.system("cls")



#### updown 게임       continue 활용, 계속하시겠습니까 활용.
while True :
    while True :
        print("="*30)
        print("1, Easy")
        print("2, Normal")
        print("3, Hard")
        print("="*30)

        level = input("난이도 설정 > ")

        if level == "1" :
            com = random.randint(1,9)
        elif level == "2" :
            com = random.randint(10,99)
        elif level == "3" :
            com = random.randint(100,999)
        else:
            print("입력오류!")
            continue
        break
    cnt = 0
    while True:
            user = input("GUESS ...")
            cnt += 1
            if user.isnumeric():
                user = int(user)
                if user > com:
                    print("DOWN!")
                elif com > user:
                    print("UP!")
                else:
                    print(f"CORRECT! {cnt}번만에 맞춤!")
                    break
            else:
                print("숫자만 입력바람!")
    again = input("계속하시겠습니까? yes(1) no(0)")
    if again == "0" :
        print("수고하셨습니다.")
        break


#### 3초후 게임 재개 하는 while 문
while True :

    ####### 게임내용#######
    
    again = input("계속하시겠습니까? (Y/N) : ")
    if again == "N":
        break
    else :
        os.system("cls")
        for i in range(3,0,-1):
            print(f"{i}초 후 게임이 재개됩니다.")
            time.sleep(1)
            os.system("cls")


#### 연산 문제
while True :
    score = 0
    life = 5
    i = 1
    while True :
        print(f"점수 : {score}")
        print(f"목숨 : {life}")
        print("="*30)
        a = random.randint(1,9)
        b = random.randint(1,9)
        c = random.randint(1,2)
        bonus = random.randint(1,4)
        lifeDD = random.randint(1,10) 
        if bonus == 1 :
            print("보너스 문제 출제!")
        if lifeDD == 1 :
            print("목숨 2개짜리 문제 출제!")
        if c == 1 :                             # 50 % 확률로 덧셈
            user = int(input(f"{a} + {b} = "))
            print()
            if user == a + b :
                print("맞았습니다.")
                if bonus == 1 :                 # 25 % 확률로 보너스 점수
                    score += 200 * (1.2**(i-1))  # 연속정답은 콤보 점수  
                else : 
                    score += 100 * (1.2**(i-1))     
                i += 1
            else : 
                print("틀렸습니다.")
                if lifeDD == 1 :                # 10 % 확률로 목숨 2개짜리 문제
                    life -= 2
                else :
                    life -= 1
                i = 1
                if life == 0 :
                    break
            time.sleep(1)
            os.system("cls")
        elif c == 2 :                           # 50 % 확률로 뺄셈
            if a > b :                          # 결과 마이너스로 안나오게 하기
                user = int(input(f"{a} - {b} = "))
                print()
                if user == a - b :
                    print("맞았습니다.")
                    if bonus == 1 :
                        score += 200 * (1.2**(i-1))     
                        i += 1
                    else : 
                        score += 100 * (1.2**(i-1))     
                        i += 1
                else : 
                    print("틀렸습니다.")
                    life -= 1
                    i = 1
                    if life == 0 :
                        break
                time.sleep(1)
                os.system("cls")
            if a < b :                          # 결과 마이너스로 안나오게 하기
                user = int(input(f"{b} - {a} = "))
                print()
                if user == b - a :
                    print("맞았습니다.")
                    if bonus == 1 :
                        score += 200 * (1.2**(i-1))     
                        i += 1
                    else : 
                        score += 100 * (1.2**(i-1))     
                        i += 1
                else : 
                    print("틀렸습니다.")
                    life -= 1
                    i = 1
                    if life == 0 :
                        break
                time.sleep(1)
                os.system("cls")                
    again = input("계속하시겠습니까? (Y/N) : ")
    if again == "N":
        break
    else :
        os.system("cls")
        for i in range(3,0,-1):
            print(f"{i}초 후 게임이 재개됩니다.")
            time.sleep(1)
            os.system("cls")


#### 위의 식은 비효율적이다. 효율적인 코드 ( 부분별로 짜준다 )

life = 5
score = 0
combo = 0
while True:
    print("="*30)
    print("목숨 : ", "♥ "*life + "♡ "*(5-life))
    print(f"콤보 : {combo}   ", "점수 : ",score)
    print("="*30)
    A = random.randint(1,9)
    B = random.randint(1,9)
    op = random.randint(1,2)
    s200 = random.randint(1,4)
    lf2 = random.randint(1,10)
    
        #### 목숨 2개 ####
    if lf2 == 1 :
        print("목숨이 2개걸린 문제입니다.")
        print()
        목숨 = 2
    else :
        목숨 = 1

        #### 200 점수 #####
    if s200 == 1 :
        print("보너스 점수 문제입니다.")
        print()
        점수 = 200 
    else : 
        점수 = 100

        #### 이 부분은 연산 선택 부분 ####

    if op == 1 :
        user = input(f"{A} + {B} = ")
        정답 = str(A+B)
    elif op == 2:
        if A >= B : 
            user = input(f"{A} - {B} = ")
            정답 = str(A-B)
        else:
            user = input(f"{B} - {A} = ")
            정답 = str(B-A)
    print()

        ##### 이부분은 채점 부분 #####

    if user == 정답:
        print("맞았습니다!")
        score += 점수 * (1 + combo * 0.2)
        combo += 1
    else:
        print("틀렸습니다!")
        life -= 목숨
        combo = 0
        if life == 0:
            print("GAMEOVER")
            break
    time.sleep(1)
    os.system("cls")


# Q. 암기게임.
# - level 당 외워야되는 숫자를 늘려준다. 단 숫자는 1초만 보여준다.
# 게임 안내단
print("암기 게임 시작 !")
time.sleep(3)
os.system("cls")
print("1초안에 단어를 암기하고 입력하세요")
time.sleep(3)
os.system("cls")
lv = 2
# 본게임 시작
while True :
    # Lv 입/출력                  
    print(f"Lv.{lv-1} START!")
    time.sleep(1.5)
    os.system("cls")
    # Lv 에 따른 문제 내기
    li = []
    for i in range(1,lv) :
        k = random.randint(1,100)
        li.append(k)
    print(li)
    time.sleep(1 + lv*0.3)
    os.system("cls")
    # 답 적기
    li2=[]
    for i in range(1,lv) :
        a = int(input(f"{i}번 숫자 : "))
        li2.append(a)
    time.sleep(0.3)
    os.system("cls")
    # 채점하기
    if li == li2 :
        print("정답입니다!")
        lv += 1
    else :
        print("오답입니다.")
        print(f"최종 도달 Lv은 {lv}단계 입니다.")
        break
    time.sleep(1)
    os.system("cls")


# Q. 인디언포커
# - 1~13까지의 숫자 중 한번씩만 낼 수 있다. 높은 사람이 이김. 이긴 횟수가 많은 사람이 이김.
while True :
    # 게임 안내단
    print()
    print()
    print("인디언포커에 오신것을 환영합니다 !\n\nContinue : (Enter...)")
    input()
    os.system("cls")
    print()
    print()
    print("""룰을 설명해 드리겠습니다.

    각자 1~13까지 중 하나의 카드를 낼 수 있으며

    숫자가 큰 사람은 100점을 획득합니다.

    단, 무승부일 시 0점을 획득합니다.\n\nContinue : (Enter...)""")
    input()
    os.system("cls")
    # 본게임단
    li1 = [1,2,3,4,5,6,7,8,9,10,11,12,13]
    li2 = [1,2,3,4,5,6,7,8,9,10,11,12,13]
    li11 = []
    li22 = []
    k = 1
    scorea = 0
    scoreb = 0
    while True :
        print(f"\n\n====={k}회=====")
        input("\n게임을 시작 하려면 : (Enter...)")
        os.system("cls")
        # 카드 고르는 단계
        print()
        print()
        print("낼 수 있는 카드 :", li1)
        print()
        a = int(input("1번 선수 낼 카드를 고르세요 : "))
        os.system("cls")
        print()
        print()
        print("낼 수 있는 카드 ", li2)
        print()
        b = int(input("2번 선수 낼 카드를 고르세요 : "))
        os.system("cls")
        # 만약 카드가 전에 골랐던 카드라면
        if a in li11 or b in li22 :
            print()
            print()
            print("골랐던 카드입니다. 다시 고르세요 ")
        # 만약 아직 고르지 않은 카드라면
        else :
            # 고른 카드는 li에서 지우기 / 고른카드들 따로 담기
            a1 = li1.index(a)
            b1 = li2.index(b)
            a2 = li1.pop(a1)
            b2 = li2.pop(b1)
            li11.append(a2)
            li22.append(b2)
            print()
            print()
            # 승패 결정하기
            if a > b :
                print("A의 승리")
                scorea +=100
            elif b > a :
                print("B의 승리")
                scoreb +=100
            elif a == b:
                print("무승부입니다.")
            print()
            print(f"점수는 A : {scorea}  vs  B : {scoreb} 입니다.")
            print()
            input("\nContinue : (Enter...)")
            k += 1
            os.system("cls")
        # 게임 종료 시점
        if li1 == [] :
            print()
            print()
            print("게임이 종료되었습니다.")
            print()
            # 총 승패 가르기
            if scorea > scoreb :
                print(f"{scorea}점 대 {scoreb}점으로 A의 승리입니다.")
            elif scorea < scoreb :
                print(f"{scorea}점 대 {scoreb}점으로 B의 승리입니다.")
            else :
                print("무승부입니다.")
            break
    # 게임을 다시 할지 묻는 코드
    os.system("cls")
    again = input("계속하시겠습니까? (Y/N) : ")
    if again == "N":
        break
    else :
        os.system("cls")
        for i in range(3,0,-1):
            print(f"{i}초 후 게임이 재개됩니다.")
            time.sleep(1)
            os.system("cls")











#------------------- Day 11----------------------

print("\n\n\n\n\n\n 06.22\n\n\n\n\n\n")

# iterable 자료형 

# str                     문자
# list/tuple/set          자료
# dict                    키

# for 문에서 i
# index 붙은 위치
# len : 기본단위 갯수
# 기본단위 in Iterable  -> True / False 

# 마이너스 인덱스 - > 뒤에서부터의 인덱스 

# 끝말잇기
print("START !")
a = input("시작 단어를 입력하세요 : ")
li = [a]
i = 0
while True : 
    b = input(f"{a} : ")
    if a[-1] == b[0] :
        print("PASS! :)")
        if b in li :
            print("사용했던 단어입니다!")
            i +=1
            if i == 3 :
                print("Fail :(")
                break
        li.append(b)
        a = b
    else :
        print("Fail :(")
        break

# 슬라이싱 - 특정 팬턴이 있는 자료를 처리할 때, 주로 사용 ! - Day1 예습때 공부

# 생년 월일 구하기
a = (input("생년월일 입력 : "))
print("생일년도 :" , a[:4])    
print("생일 월 :", a[4:6])
print("생일 일 :", a[6:])

# 2010 년생과 봄에 태어난 사람 구하기
li = ['20181127', '19860303', '20000324', '19750119', '19900407', '19850511', '20090517', '19811214', '20120125', '19920308', '20040610', '19990310', '20171126', '20160727', '19751006', '19920823', '20060103', '20171208', '19990222', '19731206', '19960824', '19970902', '19780714', '19901002', '19970224', '20091107', '19730209', '19890601', '19951003', '20051022', '19770520', '20000206', '19711221', '19820526', '20080413', '20200104', '19780204', '20030524', '20040509', '19800225', '19820327', '20130610', '19880426', '19880421', '19850101', '20011205', '19940326', '20200104', '19750823', '19701226', '20190626', '20150819', '19720626', '19890910', '20081223', '19831028', '19910406', '20160118', '20150823', '20090925', '19970812', '19800123', '20151108', '20020109', '19820414', '19920804', '20000318', '19700717', '20150610', '19840907', '19991110', '20060611', '19891204', '20030319', '19700302', '20051213', '20020216', '20050403', '19831111', '19780720', '20051218', '20000920', '19991121', '19751108', '19941216', '19891023', '20181121', '20080207', '19840818', '20040525', '19961028', '19891121', '20040411', '20121113', '19900508', '20150813', '19880622', '19830312', '20040828', '20060304', '19861025', '19770428', '19940118', '19700809', '20030414', '19951004', '19930421', '20061015', '20160410', '20011022', '19980123', '19920507', '20070602', '19930414', '20181014', '19801105', '19900409', '19850217', '19910712', '19830314', '19960424', '20080223', '19880915', '20131213', '20150724', '20040504', '20120419', '20101202', '19951120', '19851116', '19740314', '20041201', '20060703', '20070407', '20080518', '20050222', '19760416', '20091111', '19761102', '19781024', '20011002', '19750217', '19971113', '19921026', '19860128', '20181227', '19770401', '19830509', '19720417', '19921125', '20010914', '20080105', '19901207', '20020612', '19780906', '20060401', '19880316', '19720521', '20121220', '19700107', '19840804', '19990428', '20100905', '20160817', '19781107', '20000927', '20070525', '20200824', '19990620', '20201125', '20080920', '19720326', '20140925', '20070828', '19711120', '20060227', '20120605', '20181121', '20001209', '20000123', '19991004', '19810918', '19970602', '19990219', '20170603', '19720420', '19910321', '20191010', '19800125', '20171026', '20030717', '19720423', '19780912', '20150603', '19830804', '20140521', '20111010', '20080209', '20160910', '19800926', '20020821', '19990203', '20080224', '19830627', '19781220', '20160815', '19930518', '19751124', '19861121', '19940522', '20040326', '19991007', '20190425', '19760526', '19851219', '20131221', '19740405', '20160524', '19930117', '19730915', '19840323', '19760926', '19780502', '19870209', '20031121', '20140627', '20030201', '20130304', '20170326', '19830320', '19970726', '19850905', '20110127', '19881228', '20080821', '19811106', '19850411', '20171220', '19930306', '19930222', '20121223', '19760414', '19940618', '19840721', '19730118', '19980815', '19700307', '20140311', '20200313', '20070217', '20100706', '19871215', '19770518', '19910114', '20030110', '19850401', '20130923', '20201107', '20041224', '19990706', '20191115', '20040707', '20000110', '19810319', '19870726', '20040405', '19990113', '19790924', '19960817', '20100414', '19920124', '20180705', '20050116', '20130924', '20121023', '19860904', '19750614', '19781023', '19831128', '19790621', '19910106', '19960601', '19700311', '20120802', '19780306', '20030114', '19970615', '19741112', '19800410', '19870923', '19711203', '20200824', '20030415', '19820901', '20000816', '19910224', '20051203', '19990712', '19701224', '19961024', '20081216', '19741103', '19730223', '19750626', '20201118', '20131115', '19850714', '20170906', '20120213', '19820408', '19871103', '20090206', '20160218', '20000201', '19870225', '19971207', '19750317', '19751223', '20110527', '19801128', '20090206', '19911108', '19710224', '20190805', '19820124', '19881210', '19801026', '19800123', '20150112', '20060411', '20090708', '19810628', '19791205', '20190819', '19750926', '19830212', '19971127', '20120712', '20101020', '19901002', '20190321', '19840915', '20050723', '20001213', '19861018', '19940626', '19841008', '19741220', '20080812', '20091204', '20160225', '19741127', '19910610', '20041211', '19900526', '20030514', '20040712', '19951217', '19970427', '19880621', '20130219', '19921003', '19720711', '19970609', '19700101', '20181125', '20190711', '20150313', '20140415', '20061102', '19730406', '19801218', '19860823', '19970205', '20070819', '19850309', '19870804', '19940817', '19850921', '19700801', '19851013', '19710428', '19980109', '20130403', '20190908', '19910504', '20201016', '19890401', '20090915', '20081012', '19711214', '19990617', '19860906', '20050820', '19961011', '19980414', '19750916', '20090127', '20150226', '19811015', '19841218', '19890320', '20051208', '19850216', '19920301', '19700404', '19940223', '19961021', '19851215', '19760902', '19771225', '20070415', '19790604', '20140718', '19920926', '19961101', '19790625', '19790911', '20160801', '19720211', '19810426', '19981201', '20100422', '20011109', '19920904', '20040607', '20130510', '20100922', '19790709', '20070626', '20040324', '20010327', '20180923', '20070628', '19850128', '19720507', '19880513', '19951207', '19991110', '19960905', '20071122', '20071221', '19741018', '20051213', '20091213', '19900505', '19850518', '19720409', '20040526', '19880918', '19970502', '19700922', '19830408', '19730607', '20100202', '19741025', '20060818', '20170602', '19971123', '19860601', '19860906', '20120904', '19920117', '19810603', '20090318', '19770923', '19850117', '19880114', '19850814', '19990509', '20111116', '19920721', '20020822', '19840621', '19930720', '19911006', '19850606', '20170624', '20010424', '19700423', '19721014', '19710219', '19700404', '19701001', '19920724', '19851108', '20010613', '20130816', '20081206', '20200704', '19840309', '19721020', '19861212', '20090502', '20040909', '20051205', '20120719', '20180402', '19940205', '20011117', '19971227', '19881009', '19751228', '19830705', '20030523', '20080507', '19881205', '19961101', '20041209', '19740916', '19970418', '20110928', '20130911', '19791009', '20190628', '19830626', '20131110', '19701118', '19791121', '19880625', '19880211', '20140601', '20121126', '19830407', '19930523', '19760802', '19870605', '20000402', '20190921', '19980722', '19951122', '20160812', '19700620', '19901013', '19880105', '19740502', '19761205', '20000207', '19940605', '19930627', '19780812', '19780221', '19940718', '19880221', '19950810', '20120325', '20100218', '19850322', '20130218', '19870918', '19790818', '20180111', '19730718', '20010522', '20171111', '20010407', '20150628', '19781019', '20050806', '19970802', '19901113', '20091108', '19930211', '19830506', '20121013', '20101127', '20070828', '20110206', '19750123', '20090711', '19760914', '19840322', '19700918', '20050928', '19780928', '19990722', '19880519', '20011022', '19910513', '19701108', '20161214', '20040827', '19751123', '19711212', '20170914', '20170121', '19991204', '19710819', '20140917', '20150917', '19820802', '19830406', '19930507', '20021123', '20150623', '20190911', '19721125', '19800404', '20130125', '20120911', '19710928', '19980327', '20161122', '20150718', '20071122', '20190524', '19890625', '19830728', '19950624', '20070808', '19830909', '19711116', '19700208', '19980823', '19991215', '20180920', '20010727', '19760704', '20100425', '19870704', '19800813', '19871109', '19940206', '20181127', '19790312', '19820505', '20160825', '19910427', '19850916', '20131124', '20160628', '20160217', '20080612', '19910320', '20180104', '20021113', '19980611', '19920109', '19941209', '20161020', '20130223', '19710828', '19810402', '20010225', '19740510', '19810825', '19900320', '19831220', '20061113', '20030224', '19890405', '19980603', '19870124', '20201212', '20060625', '20030909', '20160406', '19741014', '20030902', '20160121', '20110816', '20131223', '19940703', '19880127', '20200526', '19730727', '20190812', '20130708', '19990808', '20160802', '20040312', '19771028', '20090406', '19911201', '20010224', '20130828', '20100514', '19831023', '20091021', '19890212', '20051025', '20170207', '19730822', '19770620', '19710702', '20080108', '20041226', '19850220', '20010505', '19730101', '19830108', '19950714', '20021003', '19960303', '20030827', '20140318', '20061210', '20180713', '20120522', '19780712', '19870320', '19801017', '20071008', '19771002', '20111108', '20111114', '19700523', '20031115', '19990312', '19980228', '20160420', '19760713', '19741125', '19770427', '20151110', '19981219', '20050708', '19861021', '19800117', '19951116', '19971221', '20040514', '19751002', '20120108', '20020919', '20180107', '19960520', '19870227', '19720322', '20161126', '19940626', '19980420', '19971224', '19771224', '20200204', '20020221', '20190328', '19960301', '19970804', '20071201', '20110801', '19810715', '19980913', '20000106', '20020816', '20180813', '19990623', '19790814', '20201021', '20150919', '19800526', '20110319', '19970317', '19960106', '20060117', '20020901', '19940904', '19970326', '19890325', '20140704', '19871201', '19881115', '19820113', '20120316', '20011110', '19730405', '19950106', '19821004', '20080118', '19950509', '19990111', '19720203', '19930824', '19701121', '19740308', '20150916', '20060319', '19931025', '19980308', '19721207', '20140928', '19770225', '19910301', '19890706', '19991005', '20140920', '19891103', '19800221', '20190614', '20100605', '19840106', '20150124', '19781019', '20030711', '19810725', '20201219', '20020616', '19950412', '19710522', '19851213', '20000501', '19801102', '19940423', '19890218', '20070501', '20080217', '20060913', '20200416', '20010304', '20100319', '20150718', '19860419', '19950115', '19820221', '19820715', '20180104', '19801209', '20180628', '19750510', '20000921', '20181018', '19791206', '20140515', '19950902', '20171123', '19920116', '20070304', '19741221', '20160325', '19731204', '19750902', '19751116', '20190703', '19700722', '20101123', '19751101', '20040525', '20070522', '19851116', '20041016', '20190715', '19881225', '19910612', '19720616', '20041106', '20200716', '19970722', '19730708', '19710823', '19730128', '19900819', '20070809', '19820802', '19870416', '19870221', '20121206', '19890411', '19911013', '20110406', '20141101', '19990624', '19761024', '20040627', '19720615', '19960407', '20130220', '20071110', '19800916', '19950916', '19950818', '19990303', '19711006', '19931111', '19720422', '19831128', '19790822', '20030115', '20150320', '19850821', '19811003', '19920604', '19930825', '20090207', '19780313', '19790828', '19751122', '19940906', '19900907', '20020618', '20040420', '20190311', '20200502', '19870727', '20050111', '19750503', '19900518', '19981119', '19760515', '19710104', '19970414', '19810718', '20080316', '19860305', '19720217', '20001124', '20050105', '20131226', '20110501', '19820625', '19990428', '20170214', '20021114', '19980404', '20050710', '20140123', '19870803', '20111119', '20060625', '19770612', '19870416', '20000209', '20080925', '20021220', '19840511', '20090925', '20150517', '19860923', '20151220', '19990801', '20070109', '20150321', '19920605', '19760212', '20091017', '19721215', '19851203', '20040506', '20010220', '19820127', '19761215', '19920523', '20020920', '20070302', '19941005', '19830323', '19741217', '20010519', '19790521', '19791117', '19750511', '19750224', '19930306', '19820213', '19780507', '19830208', '19700208', '20130203', '19711127', '19950109', '20170425', '20170405', '20050505', '19901218', '20020522', '19710921', '20200722', '19860107', '20170525', '19881019', '19710311', '20070910', '19710213', '19960727', '19820801', '19891019', '20060719', '20190919', '19700303', '19950505', '20070214', '20200212', '19970718', '19960425', '19890403', '19870317', '19780805', '20100502', '19930601', '19760401', '19930903', '19861105', '19751223', '19720307', '20040923', '19700228', '19981017', '20020228', '19941224', '20050422', '19820113']
a = 0
b = 0 
for i in li :
    if i[:4] == '2010' :
        a += 1
    if 3<=int(i[4:6]) <=5 :
        b += 1
print (a,b)

# 역방향 슬라이싱
li = ['97641000원', '86049000원', '62553000원', '56133000원', '50985000원', '75141000원', '48849000원', '31687000원', '29326000원', '30694000원', '91285000원', '24056000원', '53735000원', '85407000원', '35701000원', '1880000원', '23693000원', '84121000 원', '97185000원', '87193000원', '36494000원', '11027000원', '96641000원', '94277000원', '55728000원', '57512000원', '70302000원', '49423000원', '3714000원', '70762000원', '37698000원', '7317000원', '80764000원', '84502000원', '87567000원', '88167000원', '36248000원', '39600000원', '74350000원', '5945000원', '18918000원', '92733000원', '38012000원', '11527000원', '62759000원', '39757000원', '92423000원', '8862000원', '36473000원', '96965000원', '21957000원', '86327000원', '13540000원', '10482000원', '38013000원', '77316000원', '41107000원', '15938000원', '47160000원', '81943000원', '88015000원', '93924000원', '47772000원', '32905000원', '82585000원', '1908000원', '23926000 원', '32603000원', '25258000원', '34751000원', '86409000원', '84149000원', '10800000원', '89910000원', '97502000원', '89347000원', '22484000원', '63252000원', '5343000원', '48005000원', '74313000원', '66008000원', '9275000원', '62778000원', '68480000원', '23259000원', '71191000원', '85488000원', '54338000원', '1915000원', '50713000원', '97347000원', '39396000원', '85815000원', '18624000원', '21398000원', '37718000원', '24726000원', '69379000원', '94634000원']
a = 0
for i in li :
    b=int(i[:-1])
    a += b
print("총 금액의 합은 :",b)

# 문자열 함수 < 파이썬 고급과정에서 굉장히 중요하다.
# split -> 특정 패턴이 있는 자료에서 특정 문자를 기준으로 자를때
# ex)
# a = "010-4444-6666"
# b = "011-2425-6666"
# c = "02-155-356"
# a.split("-")    # 이때 split의 결과는 문자열 리스트이다.
# b.split("-")
# c.split("-")


# 대학 과제문제
A = input("A : ")
B = input("B : ")
x = -1
b = len(B)
while True :
    if A[-b:] == B[:x] :
        print(B[:x])
        C = A + B[x:]
        print(C)
        break
    else : 
        if -b == len(B) :
            print(A+B)
        else :
            x -= 1
            b -= 1


# 여러줄 문자열 및 split 실습 ***중요***
### 여러줄 문자열 = """" """"
st ="""
170522-4185902
010403-4195574
860122-1466919
900127-2351114
100322-4317555
810121-2609309
800426-1903277
930303-2297086
811221-2900782"""       # 원래 훨씬 길었으나 코드가 너무 더러워져서 자료 1/100으로 축소

su1 = 0
su2 = 0

for i in st.split() :           #.split() : 의미 있는 문자열 잘라 모아서 리스트로 만듬
    # print(i.split("-"))
    # print(i.split("-")[1][0])   # - 로 split 한 후 두번째 리스트의 첫번째 문자를 가져온다.
    a = i.split("-")[1][0]
    if a == '1' or a == '3' :
        su1 += 1
    else :
        su2 +=1
print(su1,su2)


# 리스트의 슬라이싱의 결과는 리스트로 나온다.

# e로 끝나는 문자 찾기

st = """culture
usually
safely
along
without
behind
beyond
below
toward"""           # 원래 훨씬 길었으나 코드가 너무 더러워 자료를 1/100으로 축소
num = 0
for i in st.split() :
    if i[-1] == 'e' :
        num +=1
print(num)

# 짝수 없는 수의 합
li = [42601, 97354, 95664, 27647, 77388, 80286, 55198, 27488, 33949, 65332, 86368, 61160, 97370, 47797, 95164, 23189, 64916, 47436, 12451, 2472, 18034, 75092, 52923, 19574, 27849, 31853, 16405, 65380, 4439, 10255, 3065, 33879, 91123, 96478, 64233, 41063, 26252, 68446, 5132, 58811, 13388, 58766, 11279, 72780, 92459, 36591, 97568, 65977, 11908, 94284, 53672, 60392, 17257, 87127, 80125, 48629, 86802, 56072, 52143, 22503, 80723, 32932, 34581, 77505, 11221, 77440, 40707, 17876, 38456, 39112, 21612, 39179, 33182, 99631, 33108, 20682, 55126, 44463, 40894, 79236, 68789, 7305, 48336, 38251, 27196, 86375, 36807, 10598, 48565, 28774, 58980, 99743, 76460, 1070, 59672, 78725, 53562, 35784, 92498, 34987, 91622, 42213, 87461, 67505, 42437, 21803, 75828, 91077, 20913, 50546, 65201, 89858, 33680, 35816, 40945, 43290, 33603, 14350, 18445, 46245, 50548, 44079, 73526, 21870, 78823, 10096, 56251, 59829, 66252, 50524, 55187, 83529, 3225, 57468, 6824, 7439, 74514, 72929, 89914, 60571, 1915, 18581, 86524, 2195, 11972, 24799, 66957, 37683, 92743, 20225, 62446, 69044, 29235, 46317, 60238, 32900, 64659, 75750, 13254, 34154, 9233, 47694, 20063, 74431, 26163, 89864, 14349, 22613, 15445, 52832, 23017, 97850, 16931, 64195, 69381, 82435, 91792, 81143, 78486, 90333, 34978, 92116, 32735, 10450, 17357, 71565, 27517, 69024, 33971, 13955, 48120, 53703, 34705, 15025, 12791, 14669, 91181, 57193, 12879, 98403, 3566, 84616, 32179, 94118, 37281, 53742, 89706, 35445, 6491, 83083, 96152, 50662, 5058, 70478, 63193, 77201, 7565, 99068, 33730, 14349, 54602, 14476, 83928, 17044, 38936, 32301, 21260, 38318, 46383, 48373, 21027, 98100, 60030, 29394, 42825, 35154, 41630, 54153, 34948, 8317, 69206, 98394, 89394, 34560, 94130, 57207, 51662, 80719, 25626, 94622, 14555, 96578, 58591, 26042, 62572, 42351, 98617, 7957, 93619, 34998, 42286, 70483, 88693, 23690, 98171, 99044, 1838, 69163, 60282, 42181, 40230, 55940, 5727, 33612, 96379, 55242, 24872, 77079, 99743, 36723, 1579, 13088, 19862, 82568, 51326, 29394, 4596, 19039, 2618, 38310, 22910, 8672, 18869, 66429, 94559, 73327, 98223, 97904, 38475, 6394, 49773, 60424, 25983, 92674, 86999, 56366, 58181, 60276, 79564, 64719, 25989, 24788, 58207, 26756, 32125, 8843, 60203, 8841, 60600, 21886, 18267, 64195, 3895, 10934, 29827, 31653, 50840, 37024, 11387, 69499, 2089, 54738, 40665, 99463, 21447, 77848, 7967, 2682, 2694, 1068, 28290, 35180, 71021, 78294, 75357, 48041, 77126, 35348, 97119, 5712, 54759, 20329, 89365, 29261, 83389, 26422, 68630, 50073, 50994, 99418, 60104, 48103, 50030, 34043, 46817, 99322, 41736, 44206, 83948, 81209, 91199, 25072, 93343, 9319, 90111, 38406, 35329, 34709, 12312, 92951, 93209, 22585, 29524, 59797, 59910, 71182, 25995, 84492, 92655, 33682, 91650, 71253, 10107, 70200, 89202, 28104, 47550, 71090, 36337, 58727, 67448, 95144, 10301, 24561, 51011, 61962, 22559, 76404, 67991, 1628, 15080, 57739, 35311, 63508, 70849, 28651, 4059, 68439, 31738, 82088, 37000, 78094, 92134, 77836, 64499, 5709, 1603, 52193, 42390, 7184, 57702, 62276, 95809, 68060, 32560, 38657, 3047, 15357, 13990, 35611, 77204, 60841, 83421, 64526, 6182, 22449, 87795, 36096, 99001, 7567, 59954, 14366, 69124, 96421, 26654, 45331, 77022, 19193, 86861, 10738, 94411, 92557, 89778, 24062, 3188, 36508, 70847, 6579, 31309, 27955, 21182, 77626, 34326, 35348, 61180, 29281, 59991, 75197, 13172, 81186, 92155, 3398, 31687, 17085, 50187, 76317, 51285, 87934, 62931, 66615, 55291, 17412, 90697, 62721, 52937, 71503, 18879, 58952, 17946, 79205, 47374, 31861, 46241, 60978, 35741, 59987, 84514, 36534, 58668, 56914, 53179, 19165, 19310, 93830, 3872, 78333, 47130, 72602, 80458, 88239, 89887, 7787, 34040, 73402, 99931, 8258, 62343, 30207, 12533, 78256, 13024, 84838, 7365, 73968, 49748, 82670, 33727, 88891, 80134, 3299, 16051, 39692, 13167, 1037, 28493, 78429, 24826, 33034, 38172, 6672, 37949, 18642, 87263, 54628, 83629, 8093, 52272, 71395, 25325, 62001, 1649, 57439, 35023, 49060, 24258, 96969, 1859, 54507, 49771, 91091, 61006, 41492, 77584, 7693, 80837, 52263, 50786, 51241, 40467, 31688, 45471, 49589, 52211, 30115, 70004, 64632, 16929, 2495, 16483, 49226, 35526, 56929, 88170, 11548, 77626, 90636, 63902, 41963, 85752, 56321, 29670, 65058, 54192, 25514, 23253, 11157, 19834, 59063, 53134, 69485, 86040, 13756, 27145, 4428, 93105, 38398, 75607, 42566, 57602, 38903, 92351, 59244, 42188, 42470, 6918, 9270, 90716, 7679, 66353, 70875, 8453, 57014, 77003, 81383, 32965, 74530, 27713, 73716, 66722, 44725, 5061, 61469, 83870, 57153, 9422, 94925, 3308, 8562, 65462, 9704, 24904, 35821, 97439, 48568, 66786, 56684, 79954, 71035, 21102, 98204, 89679, 51145, 47242, 71460, 25568, 64661, 24443, 8035, 91719, 74510, 74190, 55281, 59735, 47474, 44355, 54718, 77876, 14366, 23235, 8643, 55453, 97731, 85235, 53438, 64078, 51733, 10633, 16755, 24323, 44330, 48826, 55391, 37817, 82264, 47398, 95000, 89155, 80706, 50373, 10962, 85903, 16209, 16213, 75240, 34301, 44148, 80679, 22171, 28526, 42455, 55082, 29877, 61322, 96393, 45597, 46940, 40201, 81074, 69837, 31619, 41897, 74839, 35674, 37414, 36122, 48478, 42987, 34018, 86629, 82185, 84988, 97258, 96059, 6511, 32910, 85791, 3810, 38610, 13401, 50564, 74796, 36548, 34148, 68836, 45749, 59078, 53242, 44440, 27922, 92925, 51811, 92170, 75358, 78578, 25148, 17527, 83594, 16160, 48519, 36320, 73965, 51396, 94776, 59732, 86991, 71416, 44780, 38369, 51947, 14378, 99521, 80212, 72292, 23137, 24121, 11654, 99177, 40299, 26533, 4422, 33515, 73687, 43916, 78203, 38040, 70450, 4462, 71404, 19097, 1893, 98659, 99157, 1702, 54103, 73606, 26330, 88872, 45521, 67326, 25498, 47088, 82980, 57469, 67145, 77311, 91166, 10802, 62121, 66259, 81325, 58183, 38548, 38880, 3762, 26040, 91463, 70643, 44267, 36474, 94872, 42394, 70890, 12719, 85610, 26034, 65028, 48954, 35523, 24279, 95343, 84816, 63832, 91783, 3732, 53490, 36196, 26798, 7172, 43579, 78492, 11773, 57332, 28874, 85656, 36200, 1151, 85631, 69315, 16824, 93395, 12124, 54393, 39057, 36935, 75218, 42461, 70413, 34780, 15752, 71702, 62704, 24511, 23450, 53796, 40079, 62489, 67383, 29277, 88430, 29589, 59080, 44859, 18012, 92226, 48655, 11533, 59736, 58207, 16066, 30696, 93169, 31997, 60679, 50641, 32179, 54703, 17405, 75597, 70733, 90160, 2142, 48862, 51893, 84719, 52885, 5208, 55334, 70123, 52040, 46028, 37847, 79387, 40999, 52332, 85459, 15629, 76124, 77708, 65497, 3284, 68963, 82719, 46663, 18271, 48284, 64135, 5494, 61059, 42059, 3500, 3004, 92457, 54425, 92486, 86255, 62869, 91818, 91226, 7348, 95507, 65293, 56727, 41861, 7495, 47038, 21762, 63019, 36501, 58128, 45754, 8683, 21071, 73637, 68167, 94837, 88127, 41050, 80453, 15945, 15205, 23921, 92759, 36208, 23255, 96122, 4713, 59402, 96789, 95814, 32207, 61720, 72335, 26830, 3655, 22743, 31343, 93560, 83272, 4650, 2726, 29411, 68179, 79504, 65756, 44542, 94313, 37465, 65525, 36198, 6433, 41367, 7909, 17646, 38857, 68765, 13251, 20887, 34225, 25094, 90794, 47122, 21251, 86928, 98545, 14088, 58081, 62395, 41591, 98882, 51965]
s = 0

for i in li :
    b = 0
    a = str(i)
    for j in a :
        if int(j) % 2 == 0 :
            b += 1
    if b == 0 :
        s += i
print(s)



### 개인 게임 만들어보기(과제) ###

# (1) 소나기 게임 - 선생님 말로는 class 배우고 짜는게 효과적
# 과거 한컴타자연습에 있던 소나기 게임(숫자로) 만듬

# 개요
# - 하늘에서 1~100까지 숫자가 랜덤으로 떨어짐
# - 시간 안에 타이핑 시 숫자 삭제
# - 10회 이상 정답 시 난이도 Up!
# - 난이도 up 시 랜덤한 연산문제로 변경

# 코딩 틀
# - 1초마다 random 함수로 랜덤한 숫자를 첫줄에 생성
# - 1초가 지날때마다 숫자에 \n을 하나씩 추가하여 아래로 떨어트림
# - 마지노선(====)을 12줄 아래정도에 위치시킴
# - \n이 11개 추가되는 순간 마지노선과 닿았다고 판단하여 gameover
# - 난이도 up시 1/4의 확률로 각 연산자들을 넣기

import random
import time
b = 0
for i in range(1,12) :
    a = random.randint(1,100)
    t = random.randint(1,3)
    print("\t"*t,end="")
    print("\n",* (i-1),f"x{i}={a}",end="")

    time.sleep(1)


# (2) 침뱉는 박쥐 

# 박쥐가 파닥인다
# --> 1. 시간홀짝으로 날개 움직여주기
# 오른쪽에서 왼쪽으로 장애물 날라온다
# --> 2. " "*(30-i)를 반복하여 점점 가까워지게 하기
# 박쥐가 침뱉어서 장애물을 부순다
# --> "30-i"가 0이 되기 전에 space 입력해야한다
# --> space 입력 시 장애물 부서짐 (단 거리가 3이상일때 침뱉으면 목숨-1)
# --> 0 이 될떄까지 space를 입력 못하면 목숨 -1
# --> 장애물의 속도는 점점 빨라진다.
import time
import os

a = ''
while True :
    if input() == 'w' :
        a = "\n"
    # 1. 박쥐 움직임
    for i in range(100):
        if i % 2 == 0:
            print(f"""{a}⎛⎝(•‿•)⎠⎞""")
        if i % 2 == 1:
            print(f"""{a}◥◣(•‿•)◢◤""")
        time.sleep(0.2)
        os.system("cls")
        break   # 오류로 달아둔것. 구문돌릴떄 삭제  
    break       # 오류로 달아둔것. 삭제.




















#------------------- Day 12----------------------   

print("\n\n\n\n\n\n 06.23. \n\n\n\n\n\n")       # 다양한 함수 만들기

# koi 찾기
st = """
123453
456789"""
num = st.split()
a = 0
for i in num :
    sum = 0
    for j in i[:-1]:
        sum += (int(j)**2)
    if (sum % 10) == int(i[-1]) :
        a += 1
print(a)

# replace 함수 - 기능 x 반환만 하는 함수
# a = "apple"
# a.replace("p","t") --- 이 식에서는 p자리가 t로 바뀌지만 원본 a의 값 자체는 바뀌지않는다.

# 파일이름으로 쓸수 없는 문자 걸러주기
a = input("파일 이름 : ")
for i in '\\/":?*<>|' :
    a = a.replace(i,"")
print(a)

#"문자열".count("문자열1")
# -> 문자열 속의 문자열1 의 갯수

# "hello".count("ll")  -- 1
# "island list is perfect".count("is") -- 3
# "island list is perfect".split().count("is") -- 1
# 처음 island--- 문자열은 문자열이여서 is 가 들어가기만하면 세지만
# 두번째 거는 split 으로 자른 list 함수 이기 떄문에 list 에 담긴 값과
# 정확히 일치하는 is 하나만 나오게 된다.

# Rose - On The Ground 에서 한번만 쓰인 단어 검출하기
a = """
my life is  been magic  seems fantastic
i used to have a hole in the wall with a mattress
funny when you want it  suddenly you have it
you find out that your gold is  just plastic
every day  every night
i have  been thinking back on you and i
every day  every night
i worked my whole life
just to get right  just to be like
look at me  i am  never coming down
i worked my whole life
just to get high  just to realize
everything i need is on the
everything i need is on the ground
on the ground
everything i need is on the ground
nah  but they do not  hear me though
yeah  what goes up must come down
nah  but they do not  hear me though
you are  running out of time
my world is  been hectic  seems electric
but i have  been waking up with your voice in my head
and i am  tryna send a message and let you know that
every single minute i am  without you  i regret it
every day  every night
i have  been thinking back on you and i
every day  every night
i worked my whole life
just to get right  just to be like
look at me  i am  never coming down
i worked my whole life
just to get high  just to realize
everything i need is on the
everything i need is on the ground
on the ground
everything i need is on the ground
nah  but they do not  hear me though
yeah  what goes up must come down
nah  but they do not  hear me though
you are  running out of time
i am  way up in the clouds
and they say i have  made it now
but i figured it out
everything i need is on the ground  yeah  yeah
just drove by your house  just drove by your house
so far from you now  so far from you now
but i figured it out
everything i need is on the
everything i need is on the ground
on the ground
everything i need is on the ground
nah  but they do not  hear me though
on the ground
nah  but they do not  hear me though
everything i need is on the ground"""
b = a.split()
for i in b :
    if b.count(i) == 1 :
        print(i)

# 2*1000 에서 0~9까지 등장횟수 구하기
st = str(2**1000)
for i in "0123456789" :
    print(f"{i} : {st.count(i)}")

# 선생님 풀이
st = ""
for i in range(1,10001):
    st += str(i)
print(st.count("2"()))

# 문자열.strip()    - 기능 x 반환 o 공백을 없애주는 함수. 원함수를 변형시키지는 않음
# a = "    st   "
# a.strip() - 공백은 제거되지만 a의 원본값은 그대로 공백이 있는 채로 남아있음.

# 문자열.upper()    - 기능 x 반환 o 대문자로 바꾸어주는 함수
# 문자열.lower()    - 기능 x 반환 o 소문자로 바꾸어주는 함수

# 첫글자만 대문자로 바꾸어주기
a = input("문장 입력 : ")
print(a[0].upper() + a[1:])

# 문자열.isalpha() - 문자열이 알파벳으로만 이루어짐 - Ture 아니면 - False
# 문자열.isnumeric() - 문자열이 숫자로만 입력되어 있으면 True 아니면 False

# 입력받은 문자에서 문자의 갯수, 숫자의 갯수 구하기
a = input("입력 : ")
b = 0
c = 0
for i in a :
    if i.isalpha() :
        b += 1
    elif i.isnumeric() :
        c += 1
print(f"문자 : {b}개, 숫자 :{c}개")

# 문자열의 대소비교
# li.sort() --- 리스트내의 값들을 정렬해주는 것 (어떤 기준으로 정렬을 해줄까?)
# 유니코드 <--> 문자 (컴퓨터에서 파일이란 결국 0101로 이루어진 것.)
# 따라서 문자도 0101로 이루어지기 때문에 문자가 바뀐 유니코드의 값에 따라
# 문자의 대소관계도 따라간다.
# 유니코드를 알아보는 방법 = ord("문자")
# ord("a")=97 , ord("A")=65 ord("가")=44032
# chr() -- 유니코드에서 문자로 바꾸는 함수

# 숫자들을 문자로 바꾸기
st = "40 7432 10114 9860 5161 9461 9314 6600 41 5815 9861 9849 6160 10108 5120"
for i in st.split():
    print(chr(int(i)),end="")

# 입력받은 문자를 숫자로 바꾸기
st = input("문자입력  : ")
for i in st : 
    print(ord(i), end=" ")

# split은 문자열인 애들에서만 사용할 수 있다. list 에서 사용하는 실수 하지 않도록 하기.

# 카이사르 암호학 해독기
a = "Htwwjhy~ Z W xt Ljsnzx!! N lnaj Z uwjxjsy ktw ufxxnsl ymnx Vzjxy~ Gzy Dtz Mfaj Yt Xfd 'RTTDFMT' yt Rd Pfpft Yfqp Fhhtzsy. Mfmf~~"
b = ""
for i in a:
    if 65<=ord(i)<=90 or 97<=ord(i)<=122 :
        b += chr(ord(i) - 5)
    else : 
        b += chr(ord(i)- 26)
print(b)



















#------------------- Day 13----------------------   

print("\n\n\n\n\n\n 06.24. \n\n\n\n\n\n")               # 함수 & 클래스

# 함수 - function - 특정 기능을 수행하는 집합
# 함수 선언. 
# def [ 함수 이름 ](입력값1, 입력값2  ...) : 
#     [ 기능 구현 ]
#     return [ 반환값 ]
# 함수는 선언부가 있고 사용하는 부분이 있다. print 나 input 은 사용하는함수.
# ex. 두 수의 차이를 구하는 함수 구현
def mii(a,b):
    if a > b :
        return(a-b)
    elif a<=b :
        return(b-a)
print(mii(10,12))

# 약수함수 구현하기
def 약수함수(a) :
    약수 = []
    for i in range(1,a+1):
        if a % i == 0 :
            약수.append(i)
    return (약수)
print(약수함수(4))

# 홀짝판단 
def 홀짝판단(a) :
    if a % 2 == 0 :
        return True
    if a % 2 == 1 :
        return False
print(홀짝판단(12))

# 소수판단
def 소수판단(a) :
    x = 0
    for i in range(2,a):
        if a % i == 0 :
            x += 1
    if x == 0 :
        return True
    if x > 0 :
        return False
print(소수판단(11))

# 소수판단 - 샘 풀이
def 소수판단(a) :
    for i in range(2,a):
        if a % i == 0 :
            return False
    return True
print(소수판단(11))

# 홀수로만 이루어져있으면 True 아니면 False
def 홀수로만(a) :
    x = str(a)
    for i in x :
        if int(i) % 2 == 0 :
            return False
    return True
print(홀수로만(131332))

# if type(n) == int  이런식으로 타입을 검사하여 함수를 구현할 수도 있다. 

# 걸러주기 함수
def 걸러줌(a) : 
    for i in "<>|/\\\"?*:":
        a = a.replace(i,"")
    return(a)

print(걸러줌("\\./asdgdg"))

# 요약하기 함수
def 요약(a,b) :
    if len(a) >= b :
        return(a[:b] + "...")
    else :
        return(a)
print(요약("hello world",3))
print(요약("hello world",7))
print(요약("hello world",20))

# 함수를 사용하는 이유 - 간결성 / 재사용성

# 함수를 잘 사용한 간단한 예시
def 유효값반환(문구,최소,최대) :
    while True :
        N = input(문구)
        if N.isnumeric() :
            N = int(N)
            if 최소 <= N <= 최대 :
                return N
            else :
                print(f"{최소}~{최대}사이의 수를 입력해주세요!")
        else :
            print("숫자만 입력해주세요!")
국어점수 = 유효값반환("국어점수 : ",0,100)
수학점수 = 유효값반환("수학점수 : ",0,100)
영어점수 = 유효값반환("영어점수 : ",0,100)
print(f"평균은 {(국어점수+수학점수+영어점수)/3}")

# 함수는 괄호를 열고닫고해야 실행이 된다. 괄호 여/닫지 않으면 함수실행 안됨
# 반환값이 없는 경우 받으면 None이 나온다. 


# 클래스(class)

# 속성/성질을 변수로 빼고 특징/행동을 함수로 뺴서 묶는다.
# 클래스 = 필드(변수) + 매서드(함수)
# ex) 사람 클래스 = 변수(키,몸무게,시력 ..) + 함수(잔다,걷는다,뛴다 ..)

# 클래스는 객체를 생성하기 위해서 만든다.

# ex) Maple Story 의 모험가 class

class 모험가 :          
    # class 안의 변수 : 필드
    힘 = 10             
    민첩 = 10
    지능 = 10
    운 = 10
    항마력 = 10
    닉네임 = ""
    인벤 = []
    # class 안의 함수 : 매서드
    def 걷는다() :     
        pass
    def 뛴다() :
        pass
A = 모험가()
# A는 객체이며 인스턴스이지만, 표현의 차이가 있다. 
# 객체는 독단적으로, 인스턴스는 class와 함께 쓰는 표현
# A 는 객체, A는 모험가 class 의 인스턴스다 ! (o)
# A 는 인스턴스, A는 모험가 class 의 객체다 ! (x)

print(A.지능)

# A는 모험가 class 의 인스턴스이기 때문에 모험가라면 할 수 있는 
# 속성, 행동에 접근할 수 있다.
# 클래스의 첫 글자는 무조건 대문자로 쓰기로 개발자들끼리 약속을 하였다.

# pip : pypi.org 에서 다른 개발자들이 개발해놓은 소스를 컴퓨터로 다운받을 수 있도록 
# 해주는 프로그램

# import : 다른 파일에 있는 클래스, 함수, 변수를 해당 파일에서 사용할 수 있도록 
# 만들어주는 구문

# pip 설치는 했는데 code에서 안돌아갈때.
# 1. cmd창에서 python 이라고 친다.
# 2. 버전 챙기기
# 3. 코드 인터프리터와 일치시켜야한다.(우측하단)


# pip 및 import 예시    - 구글 번역기 실행해보기
# 구글에서 pip 파일을 받아온다. (cmd창에서 설치)
# 코드 창에서 import 로 googletrans 를 가져온다.
import googletrans
from googletrans import Translator

# print(googletrans.LANGUAGES)

text1 = "Hello welcome to my website!"

text2 = "안녕하세요! 환영합니다."

text3 ="한글을 영어로 번역합니다"

translator = Translator()

print(translator.detect(text1))
print(translator.detect(text2))
print(translator.detect(text3))

trans1 = translator.translate(text1, src='en', dest='ja')
trans2 = translator.translate(text2, src='ko', dest='de')
trans3 = translator.translate(text3, src='ko', dest='en')

print("English to Japanese: ", trans1.text)
print("Korean to Germany: ", trans2.text)
print("Korean to English: ", trans3.text)































#------------------- Day 14----------------------   

print("\n\n\n\n\n\n 06.27. \n\n\n\n\n\n")               # import 에 관하여 / set에 관하여

# ex01 과 ex02를 나누어서 01에 class를 만들어 02에서 import로 가져오는 연습.
# ex02에 여러가지 이론 필기
# ex01, ex02, 그림그리기, dyna 파일에 연습!!






































#------------------- Day 15----------------------   

print("\n\n\n\n\n\n 06.28. \n\n\n\n\n\n")       #파일 실행

# 단어장만들기
import time
import os
d = {}
while True :
    # 메뉴 출력단
    print("="*30)
    print("1. 단어목록 보기")
    print("2. 단어 검색")
    print("3. 단어 추가")
    print("4. 단어 수정")
    print("5. 단어 삭제")
    print("6. 프로그램 종료")
    print("="*30)
    # 메뉴 입력단
    a = input("메뉴를 입력하세요 : ")
    # 메뉴에 따른 출력단
    if   a == '1' :
        for i in d :
            print(i)
    elif a == '2' :
        b = input("단어를 검색해주세요 : ")
        if b in a :
            print(a[b])
        else : 
            print("단어를 잘못입력하셨습니다.")
    elif a == '3' :
        b = input("추가할 단어를 입력해주세요 : ")
        if b in a :
            print("단어가 이미 존재합니다.")
        else :
            c = input("뜻을 입력해주세요 : ")
            d[b] = c
            print(b,"가 추가되었습니다.")
    elif a == '4' :
        b = input("수정할 단어를 입력해주세요 : ")
        if b in a : 
            c = input("뜻을 입력해주세요 : ")
            d[b] = c
            print("수정되었습니다.")
        else : 
            print("단어를 잘못입력하셨습니다.")
    elif a == '5' :
        b = input("삭제할 단어를 입력해주세요 : ")
        if b in a :
            del d[b]
            print("삭제되었습니다.")
        else : 
            print("단어를 잘못입력하셨습니다.")
    elif a == '6' :
        print("프로그램을 종료합니다.")
        break
    else :
        print("잘못입력하셨습니다.")
    time.sleep(1)
    os.system("cls")


# 파일 열기 및 경로 연습
f = open("abc/test.txt","w")        # test.txt 라는 파일이 생성된다.
# open(A,B)
# A = 파일경로를 포함한 파일이름
# B = 권한

# A : 파일경로 (절대경로-드라이브로부터의 경로(드라이브:로 시작) / 상대경로-현재 위치로부터의 경로)
f = open("testa/a.txt","w")
f = open("testa/testb/b.png","w")
f = open("testa/testb/testc/c.cpp","w")

# B = (권한) r w a 
# r(read,읽기) - 경로를 잘 확인하여 읽어야한다.
# w(write,쓰기) - 있는 파일을 쓰게되면 내용이 다 날아간다(새로쓰기)
# a(append,덧붙여쓰기)

# 쓰기 실습 
f = open("test.txt","w")
f.write("hello")    # f.write(x) - x를 써준다.
f.write("안녕")     # 한글은 이상하게 나온다. why? -> 인코딩 cp949 방식과 utf-8의 차이. 밖에선 잘열리니 괜찮다.
# 인코딩 : 어떤 데이터를 0101로 바꾸기 - 
# 디코딩 : 0101을 데이터로 바꾸기
# 이럴때는 어떻게하면된다? 인코딩도 utf-8로 해주면된다
f = open("test.txt","w",encoding="utf-8")
f.write("안녕")

# 예제. 파이썬존잼 1~ 100 출력하기
f = open("test.txt","w",encoding="utf-8")
for i in range(1,101) :
    f.write(f"파이썬 존잼{i}\n")

# 구구단 폴더 생성
# 2단.txt, 3단.txt ~~ 
for i in range (2,10) :
    f = open(f"구구단/{i}단.txt","w",encoding="utf-8")
    for j in range(1,10):
        f.write(f"{i}x{j}={i*j}\n")

# 읽기 실습
f = open("test.txt","r",encoding="utf-8")
print(f.read())                 # 전체를 읽는다.    
print(f.readline())             # 한 줄만 읽는다.
print(f.readlines())            # 한줄한줄 리스트에 담아서 읽는다
# 다같이 출력해보면 이상하게 나온다. 
# 이유 : f 는 파일 포인터이다. - 커서를 옮겨주는애
# 이미 아래로 한칸한칸 커서가 옮겨져있기 때문에 출력은 항상 다음거부터 나온다.

# 구구단 읽기
for i in range(2,10) :
    f = open(f"구구단/{i}단.txt","r",)
    print(f.read())


# 딕셔너리 복습 - key : value
# ex. key에 상품 - value 에 상품설명[가격,원산지,...] 등 list가 매칭될수도있다.
# 딕셔너리 선언 > 주석으로 key,value 들어가있는 의미 작성
# key indexing : key를 가지고 value 에 접근 !!
d = {}  # 빈 딕셔너리
d = {1:"one",2:"two",3:"three"}
# print(d[3])     # key 오류
print(d["3"])
# 없는 key값이 들어가면 추가가 된다.
d[4] = 4
# in 멤버연산자를 통해 기존에 있는지 없는지 판단해준다.
print(1 in d)   # key 있으면 True 없으면 False / value 는 상관없음
# for 문과 딕셔너리 : key값이 돌아간다

# 자료형 총 정리
# 숫자 / 문자열 / bool / list / tuple / set / dict
# str,list,tuple -- 순서가 있는 연속적인 자료. 인덱스 존재. 인덱싱/슬라이싱 가능
# str,list,tuple,set,dict -- iterable한 자료. for 문에 사용가능/ in멤버연산자 가능 / len 등 가능
# str - 문자 , list/tuple/set - 자료, dict - 키값
# set - 중복이없다

# 단어장(심화) 파일에서 불러와서 파일에 저장하기
import time
import os
d = {}
f = open("단어장", "r",encoding="utf-8")
k = f.read().split(',')
for i in range(0,len(k)-1,2) :
    키값 = k[i]
    벨류값 = k[i+1]
    d[키값] = 벨류값
while True :
    # 메뉴 출력단
    print("="*30)
    print("1. 단어목록 보기")
    print("2. 단어 검색")
    print("3. 단어 추가")
    print("4. 단어 수정")
    print("5. 단어 삭제")
    print("6. 프로그램 종료")
    print("="*30)
    # 메뉴 입력단
    a = input("메뉴를 입력하세요 : ")
    # 메뉴에 따른 출력단
    if   a == '1' :
        for i in d :
            print(i)
    elif a == '2' :
        b = input("단어를 검색해주세요 : ")
        if b in a :
            print(a[b])
        else : 
            print("단어를 잘못입력하셨습니다.")
    elif a == '3' :
        b = input("추가할 단어를 입력해주세요 : ")
        if b in a :
            print("단어가 이미 존재합니다.")
        else :
            c = input("뜻을 입력해주세요 : ")
            d[b] = c
            print(b,"가 추가되었습니다.")
    elif a == '4' :
        b = input("수정할 단어를 입력해주세요 : ")
        if b in a : 
            c = input("뜻을 입력해주세요 : ")
            d[b] = c
            print("수정되었습니다.")
        else : 
            print("단어를 잘못입력하셨습니다.")
    elif a == '5' :
        b = input("삭제할 단어를 입력해주세요 : ")
        if b in a :
            del d[b]
            print("삭제되었습니다.")
        else : 
            print("단어를 잘못입력하셨습니다.")
    elif a == '6' :
        print("프로그램을 종료합니다.")
        break
    else :
        print("잘못입력하셨습니다.")
    time.sleep(1)
    os.system("cls")
f = open("단어장","w",encoding="utf-8")
for i in d :
    f.write(f"{i},{d[i]}\n")

